void osl::NumEffectState::makeKing8Info()
template<osl::Player P>

}
  return King8Info(Iking8Info(king));
{
NumEffectState::king8Info(Player king) const
const osl::checkmate::King8Info osl::

}
          == static_cast<const SimpleState&>(st2));
  return (static_cast<const SimpleState&>(st1)
    return false;
  if (!(st1.king8infos == st2.king8infos)) 
    return false;
  if (!(st1.king_mobility == st2.king_mobility)) 
    return false;
  if (!(st1.pin_or_open == st2.pin_or_open)) 
    return false;
  if (!(st1.promoted == st2.promoted)) 
    return false;
  if (!(st1.pieces_onboard == st2.pieces_onboard)) 
    return false;
  if (!(st1.effects == st2.effects)) 
  assert(st2.isConsistent(true));
  assert(st1.isConsistent(true));
{
                            const NumEffectState& st2)
bool osl::operator==(const NumEffectState& st1,

#endif
typedef __v2di v2di;
#include <emmintrin.h>
#if (defined(__i386__) || defined(__x86_64__)) && !defined(OSL_NO_SSE)
#include <iostream>

#include "osl/move_generator/effect_action.h"
#include "osl/move_generator/move_action.h"
#include "osl/move_generator/escape_.h"
#include "osl/move_generator/allMoves.h"
#include "osl/move_classifier/pawnDropCheckmate.h"
#include "osl/move_classifier/safeMove.h"
#include "osl/move_classifier/check_.h"
#include "osl/move_classifier/moveAdaptor.h"
#include "osl/bits/numSimpleEffect.tcc"
#include "osl/simpleState.tcc"
#include "osl/numEffectState.tcc"
#include "osl/numEffectState.h"
 */
/* numEffectState.cc
NumEffectState::selectCheapPiece(PieceMask effect) const
const osl::Piece osl::

}
{
NumEffectState::~NumEffectState() 
osl::
}
    makeKing8Info<WHITE>();
  if(kingSquare<WHITE>().isOnBoard())
    makeKing8Info<BLACK>();
  if(kingSquare<BLACK>().isOnBoard())
  makePinOpen(WHITE);
  makePinOpen(BLACK);
  }
    }
      }
        }
          effects.effected_changed_mask[i].set(num);
          effects.effected_mask[i].set(num);
        {
        if(hasEffectAt(pl,p.square()))
        Player pl=indexToPlayer(i);
      for(int i=0;i<2;i++){
        promoted.set(num);
      if (p.isPromoted())
      pieces_onboard[p.owner()].set(num);
    if (p.isOnBoard()){
    Piece p=pieceOf(num);
  for(int num=0;num<40;num++){
  effects.effected_changed_mask[1].resetAll();
  effects.effected_changed_mask[0].resetAll();
  effects.effected_mask[1].resetAll();
  effects.effected_mask[0].resetAll();
  promoted.resetAll();
  pieces_onboard[1].resetAll();
  pieces_onboard[0].resetAll();
{
  : SimpleState(st),effects(st)
NumEffectState::NumEffectState(const SimpleState& st) 
osl::

}
  king8infos[P]=King8Info::make<altP>(*this,kingSquare<P>()).uint64Value();
#endif
    return;
  if (kingSquare<P>().isPieceStand())
#ifdef ALLOW_KING_ABSENCE
  const Player altP=alt(P);
{
    if (promoted.any()) {
    mask_t notpromoted = all & ~promoted;
    mask_t promoted = all & promotedPieces().getMask(i);
    mask_t all = nolance.getMask(i);
  for (int i=lance_index; i>=0; --i) {
  const int lance_index = PtypeFuns<LANCE>::indexNum; // 64bit: 0, 32bit: 1
  int pp=-1, npp=-1, ret=-1;
  PieceMask nolance = pieces; nolance.clearBit<LANCE>();
  PieceMask pieces = piecesOnBoard(P) & effectedMask(alt(P));
  assert(! inCheck(P));
{
NumEffectState::findThreatenedPiece(Player P) const
const osl::Piece osl::

}
  return pieceOf(std::min(num, nump));
    return pieceOf(num);
  if (Piece_Table.getPtypeOf(num) == Piece_Table.getPtypeOf(nump))
  const int num = pieces.bsf(), nump = ppieces.bsf();
    return pieceOf(pieces.any() ? pieces.bsf() : ppieces.bsf());
  if (pieces.none() || ppieces.none())
  pieces = effect.getMask(index) & ~ppieces;
  ppieces = effect.getMask(index) & promoted.getMask(index);
  const int index = 0;
  // depends on current piece numbers: <FU 0>, KE 18, GI 22, KI 26, <OU 30>, <KY 32>, KA 36, HI 38, 
    return pieceOf(king.bsf()+PtypeFuns<KING>::indexNum*32);
  if (effect.none())
  effect.clearBit<KING>();
  mask_t king = effect.selectBit<KING>();
  }
    return pieceOf(ppieces.bsf()+PtypeFuns<LANCE>::indexNum*32);
      return pieceOf(pieces.bsf()+PtypeFuns<LANCE>::indexNum*32);
    if (pieces.any())
    pieces &= ~ppieces;
    ppieces = pieces & promoted.getMask<LANCE>();
  {
  if (pieces.any()) 
  pieces = effect.selectBit<LANCE>();
  }
    return pieceOf(ppieces.bsf()+PtypeFuns<PAWN>::indexNum*32);
      return pieceOf(pieces.bsf()+PtypeFuns<PAWN>::indexNum*32);
    if (pieces.any())
    pieces &= ~ppieces;
    ppieces = pieces & promoted.getMask<PAWN>();
  {
  if (pieces.any()) 
  mask_t pieces = effect.selectBit<PAWN>(), ppieces;
    return Piece::EMPTY();
  if (! effect.any())
{

}
    !=primDirUnsafe(Board_Table.getShort8Unsafe(piece.owner(), from,to));
  return primDir(d)
  const Direction d=pinnedDir(piece);
    return true;
  if (last_move.isDrop() || last_move.oldPtype() == KNIGHT)
    return false;
  if (! pin(alt(turn())).test(piece.number()))
  const Piece piece = pieceOnBoard(to);
                                    kingSquare(alt(turn())));
      && !Board_Table.isBetweenSafe(from, to, 
                       kingSquare(alt(turn())))
    return hasEffectIf(last_move.capturePtypeO(), to,
  if (last_move.isCapture())
  }
    return hasEffectAt(turn(), from);
      return true;
        && hasEffectIf(last_move.capturePtypeO(), to, from))
    if (last_move.isCapture()
  if (last_move.ptype() == KING) {
  const Square from = last_move.from(), to = last_move.to();
    return false;
  if (! last_move.isNormal())
{
NumEffectState::wasCheckEvasion(Move last_move) const
bool osl::

}
  return Piece::EMPTY();
  }
    return pieceOf(ret);
    assert(Piece_Table.getPtypeOf(ret) == PAWN);
  if (ret >= 0) {
  }
    return pieceOf(lance.bsr()+lance_index*32);
      return pieceOf(plance.bsr()+lance_index*32);
    if (plance.any())
    mask_t plance = lance & promotedPieces().getMask(lance_index);
  if (lance.any()) {
  mask_t lance = pieces.selectBit<LANCE>();
  }
      return pieceOf(ret);  
    if (ret >= PtypeTraits<KNIGHT>::indexMin)
    ret = std::max(pp, npp);
      npp = notpromoted.bsr() + i*32;
    if (notpromoted.any())
    }
      notpromoted &= ~Ptype_Table.getMaskLow(Piece_Table.getPtypeOf(pp));
      pp = promoted.bsr() + i*32;
  else{
  }
                   promoted_backup, effected_mask_backup, effected_changed_mask_backup,king8infos_backup,mobilityTable);
                   pin_or_open_backup, king_mobility_backup,
                   oldPiece, num, oldPtypeO, newPtypeO, 
    prologueSimple(Player2Type<BLACK>(), from, to, promoteMask, 
  if (turn()==BLACK){
  mobility::MobilityTable mobilityTable;
  CArray<uint64_t,2> king8infos_backup;
  CArray<PieceMask,2> effected_changed_mask_backup;
  CArray<PieceMask,2> effected_mask_backup;
  PieceMask promoted_backup;
  KingMobility king_mobility_backup;
  CArray<PieceMask,2> pin_or_open_backup;
  PtypeO oldPtypeO, newPtypeO;
  int num;
  Piece oldPiece;
{
doSimpleMove(Square from, Square to, int promoteMask)
void osl::NumEffectState::

}
  changeTurn();
  }
    }
      doSimpleMove(from,to,move.promoteMask());
    {
    else
    }
      doCaptureMove(from,to,captured,move.promoteMask());
    {
    if (captured != Piece::EMPTY())
    const Piece captured = pieceOnBoard(to);
  {
  else
  }
    doDropMove(to,move.ptype());
  {
  if (from.isPieceStand())
  const Square to=move.to();
  const Square from=move.from();
  assert(isAlmostValidMove(move));

  }
    return;
    makeMovePass();
  if (move.isPass()) {
  assert(turn() == move.player());
{
void osl::NumEffectState::makeMove(Move move)
  KingMobility king_mobility_backup;
  CArray<PieceMask,2> pin_or_open_backup;
  mask_t numMask;
  int num, numIndex;
  PtypeO ptypeO;
  Piece oldPiece;
{
doDropMove(Square to,Ptype ptype)
void osl::NumEffectState::

}
    clearPawn(turn(),from);
  if (promoteMask!=0 && num0<PtypeTraits<PAWN>::indexLimit)
    clearPawn(alt(turn()),to);
  if (capturePtype==PAWN)
  const Ptype capturePtype=target.ptype();
  }
                    promoted_backup, effected_mask_backup, effected_changed_mask_backup,king8infos_backup,mobilityTable);
                    pin_or_open_backup, king_mobility_backup,
                    capturePtypeO, newPtypeO, num0, num1, num1Index,num1Mask, 
    prologueCapture(Player2Type<WHITE>(), from, to, target, promoteMask, oldPiece, oldPtypeO, 
  else{
  }
                    promoted_backup, effected_mask_backup, effected_changed_mask_backup,king8infos_backup,mobilityTable);
                    pin_or_open_backup, king_mobility_backup,
                    capturePtypeO, newPtypeO, num0, num1, num1Index,num1Mask, 
    prologueCapture(Player2Type<BLACK>(), from, to, target, promoteMask, oldPiece, oldPtypeO, 
  if(turn()==BLACK){
  mobility::MobilityTable mobilityTable;
  CArray<uint64_t,2> king8infos_backup;
  CArray<PieceMask,2> effected_changed_mask_backup;
  CArray<PieceMask,2> effected_mask_backup;
  PieceMask promoted_backup;
  KingMobility king_mobility_backup;
  CArray<PieceMask,2> pin_or_open_backup;
  mask_t num1Mask;
  int num0, num1, num1Index;
  PtypeO oldPtypeO, capturePtypeO, newPtypeO;
  Piece oldPiece;
{
doCaptureMove(Square from, Square to, Piece target, int promoteMask)
void osl::NumEffectState::
}
    clearPawn(turn(),from);
  if (promoteMask!=0 && num < PtypeTraits<PAWN>::indexLimit)
  }
                   promoted_backup, effected_mask_backup, effected_changed_mask_backup,king8infos_backup,mobilityTable);
                   pin_or_open_backup, king_mobility_backup,
                   oldPiece, num, oldPtypeO, newPtypeO, 
    prologueSimple(Player2Type<WHITE>(), from, to, promoteMask, 
  effects.template doEffect<NumBitmapEffect::Sub,true>(*this,oldPtypeO,from,num);
  effects.clearEffectedChanged();
  effects.clearChangedEffects();
  setPieceOf(num,newPiece);
  // 自分自身の効きを外す
  new_ptypeo=newPiece.ptypeO();
  oldPtypeO=oldPiece.ptypeO();

  num=oldPiece.number();
  newPiece+=(to-from);
  Piece newPiece=oldPiece.promoteWithMask(promoteMask);
  oldPiece=pieceAt(from);

  king8infos_backup=king8infos;
  effected_changed_mask_backup = effects.effected_changed_mask;
  effected_mask_backup = effects.effected_mask;
  king_mobility_backup = king_mobility;
  pin_or_open_backup = pin_or_open;
  mobility_backup = effects.mobilityTable;
{
               MobilityTable &mobility_backup)
               CArray<uint64_t,2>& king8infos_backup,
               CArray<PieceMask,2>& effected_changed_mask_backup,
               CArray<PieceMask,2>& effected_mask_backup,
               PieceMask& promoted_backup,
               KingMobility& king_mobility_backup,
               CArray<PieceMask,2>& pin_or_open_backup,
               PtypeO& oldPtypeO, PtypeO& new_ptypeo,
               Piece& oldPiece, int& num, 
prologueSimple(Player2Type<P>, Square from, Square to, int promoteMask,
void osl::NumEffectState::
template<osl::Player P>

}
    setPawn(turn(),to);
  if (ptype==PAWN)
  }
                 effected_mask_backup, effected_changed_mask_backup,king8infos_backup,mobilityTable);
                 pin_or_open_backup, king_mobility_backup,
    prologueDrop(Player2Type<WHITE>(), to, ptype, oldPiece, num, ptypeO, numIndex, numMask, 
  else{
  }
                 effected_mask_backup, effected_changed_mask_backup,king8infos_backup,mobilityTable);
                 pin_or_open_backup, king_mobility_backup,
    prologueDrop(Player2Type<BLACK>(), to, ptype, oldPiece, num, ptypeO, numIndex, numMask, 
  if(turn()==BLACK){
  mobility::MobilityTable mobilityTable;
  CArray<uint64_t,2> king8infos_backup;
  CArray<PieceMask,2> effected_changed_mask_backup;
  CArray<PieceMask,2> effected_mask_backup;
void osl::NumEffectState::

}
  }
      makeKing8Info<WHITE>();
       || pin_or_open[WHITE]!=pin_or_open_backup[WHITE])
    if(changed.anyInRange(Board_Mask_Table3x3.mask(kingSquare<WHITE>()))
      makeKing8Info<BLACK>();
       || pin_or_open[BLACK]!=pin_or_open_backup[BLACK])
    if(changed.anyInRange(Board_Mask_Table3x3.mask(kingSquare<BLACK>()))
    changed.set(to);
    changed.set(from);
    BoardMask changed=changedEffects(BLACK)|changedEffects(WHITE);
  {
  effects.effected_changed_mask[WHITE].set(num);
  effects.effected_changed_mask[BLACK].set(num);
    effects.effected_mask[WHITE].reset(num);
  else
    effects.effected_mask[WHITE].set(num);
  if(hasEffectAt(WHITE,to))
    effects.effected_mask[BLACK].reset(num);
  else
    effects.effected_mask[BLACK].set(num);
  if(hasEffectAt(BLACK,to))
    promoted.set(num);
  if (promoteMask)
  promoted_backup = promoted;
  }
    recalcPinOpen(to,lastD,alt(P));
    recalcPinOpen(from,lastD,alt(P));
    pin_or_open[alt(P)].reset(num);
    Direction lastD=UL;
  {
  }
    recalcPinOpen(to,lastD,P);
    recalcPinOpen(from,lastD,P);
    pin_or_open[P].reset(num);
    Direction lastD=UL;
  else {
    makePinOpen(P);
  if (oldPtypeO == newPtypeO(P,KING))

  effects.template doEffect<NumBitmapEffect::Add,true>(*this,new_ptypeo,to,num);
  effects.template doBlockAt<NumBitmapEffect::Add,true>(*this,from,num);
  setBoard(from,Piece::EMPTY());
  effects.template doBlockAt<NumBitmapEffect::Sub,true>(*this,to,num);
  setBoard(to,newPiece);
  effects.effectedNumTable[num].clear();
  // あるいは自分自身のブロック
  // 自分自身がブロックしていたpromote?の延長
  numIndex=Ptype_Table.getIndex(ptype);
#elif OSL_WORDSIZE == 32
  numIndex=0;
#if OSL_WORDSIZE == 64
  effected_changed_mask_backup = effects.effected_changed_mask;
  effected_mask_backup = effects.effected_mask;
  king_mobility_backup = king_mobility;
  pin_or_open_backup = pin_or_open;
  mobility_backup = effects.mobilityTable;
  king8infos_backup = king8infos;
{
             MobilityTable &mobility_backup)
             CArray<uint64_t,2>& king8infos_backup,
             CArray<PieceMask,2>& effected_changed_mask_backup,
             CArray<PieceMask,2>& effected_mask_backup,
             KingMobility& king_mobility_backup,
             CArray<PieceMask,2>& pin_or_open_backup,
             int& numIndex, mask_t& numMask,
             Piece& oldPiece, int& num, PtypeO& ptypeO, 
prologueDrop(Player2Type<P>, Square to, Ptype ptype,
void osl::NumEffectState::
template<osl::Player P>

}
  king8infos = king8infos_backup;
  effects.mobilityTable = mobility_backup;
  effects.effected_changed_mask = effected_changed_mask_backup;
  effects.effected_mask = effected_mask_backup;
  promoted = promoted_backup;
  king_mobility = king_mobility_backup;
  pin_or_open = pin_or_open_backup;
  effects.invalidateChangedEffects();
  effects.doEffect<NumBitmapEffect::Add,false>(*this,oldPtypeO,from,num);
  effects.doBlockAt<NumBitmapEffect::Add,false>(*this,to,num);
  setBoard(to,Piece::EMPTY());
  effects.doBlockAt<NumBitmapEffect::Sub,false>(*this,from,num);
  effects.effectedNumTable[num].clear();
  setBoard(from,oldPiece);
  effects.doEffect<NumBitmapEffect::Sub,false>(*this,newPtypeO,to,num);
  setPieceOf(num,oldPiece);
{
               const MobilityTable & mobility_backup)
               const CArray<uint64_t,2>& king8infos_backup,
               const CArray<PieceMask,2>& effected_changed_mask_backup,
               const CArray<PieceMask,2>& effected_mask_backup,
               const PieceMask& promoted_backup,
               const KingMobility& king_mobility_backup,
               const CArray<PieceMask,2>& pin_or_open_backup,
               int num, PtypeO oldPtypeO, PtypeO newPtypeO,
epilogueSimple(Square from, Square to, Piece oldPiece, 

}
  }
      makeKing8Info<WHITE>();
       || pin_or_open[WHITE]!=pin_or_open_backup[WHITE])
    if(changed.anyInRange(Board_Mask_Table3x3.mask(kingSquare<WHITE>()))
      makeKing8Info<BLACK>();
       || pin_or_open[BLACK]!=pin_or_open_backup[BLACK])
    if(changed.anyInRange(Board_Mask_Table3x3.mask(kingSquare<BLACK>()))
    changed.set(to);
    BoardMask changed=changedEffects(BLACK)|changedEffects(WHITE);
  {
  effects.effected_changed_mask[WHITE].set(num);
  effects.effected_changed_mask[BLACK].set(num);
    effects.effected_mask[WHITE].reset(num);
  else
    effects.effected_mask[WHITE].set(num);
  if (hasEffectAt(WHITE,to))
    effects.effected_mask[BLACK].reset(num);
  else
    effects.effected_mask[BLACK].set(num);
  if(hasEffectAt(BLACK,to))
  }
    recalcPinOpen(to,lastD,alt(P));
    Direction lastD=UL;
  {
  }
    recalcPinOpen(to,lastD,P);
    Direction lastD=UL;
  {
  pieces_onboard[P].xorMask(numIndex,numMask);
  stand_count[P][ptype-PTYPE_BASIC_MIN]--;
  standMask(P).xorMask(numIndex,numMask);
  setBoard(to,newPiece);
  effects.template doEffect<NumBitmapEffect::Add,true>(*this,ptypeO,to,num);
  effects.template doBlockAt<NumBitmapEffect::Sub,true>(*this,to,num);
  effects.clearEffectedChanged();
  effects.clearChangedEffects();
  setPieceOf(num,newPiece);
  ptypeO=newPiece.ptypeO();
  newPiece+=to-Square::STAND();
  Piece newPiece=oldPiece;
  oldPiece=pieceOf(num);
  num = numLow|(numIndex<<5);
  int numLow = ownMochigoma.bsf();
  numMask=ownMochigoma.lowestBit();
  assert(ownMochigoma.any());
    standMask(P).getMask(numIndex) & Ptype_Table.getMaskLow(ptype);
  const mask_t ownMochigoma=
#endif

  king8infos_backup = king8infos;
  effected_changed_mask_backup = effects.effected_changed_mask;
  effected_mask_backup = effects.effected_mask;
  king_mobility_backup = king_mobility;
  pin_or_open_backup = pin_or_open;
  mobility_backup = effects.mobilityTable;
{
                MobilityTable &mobility_backup)
                CArray<uint64_t,2>& king8infos_backup,
                CArray<PieceMask,2>& effected_changed_mask_backup,
                CArray<PieceMask,2>& effected_mask_backup,
                PieceMask& promoted_backup,
                KingMobility& king_mobility_backup,
                CArray<PieceMask,2>& pin_or_open_backup,
                int& num1Index, mask_t& num1Mask,
                PtypeO& new_ptypeo, int& num0, int& num1, 
                Piece& oldPiece, PtypeO& oldPtypeO, PtypeO& capturePtypeO, 
                int promoteMask,
prologueCapture(Player2Type<P>, Square from, Square to, Piece target, 
void osl::NumEffectState::
template<osl::Player P>

}
  king8infos = king8infos_backup;
  effects.mobilityTable = mobility_backup;
  effects.effected_changed_mask = effected_changed_mask_backup;
  effects.effected_mask = effected_mask_backup;
  king_mobility = king_mobility_backup;
  pin_or_open = pin_or_open_backup;
  effects.invalidateChangedEffects();
  effects.effectedNumTable[num].clear();
  setPieceOf(num,oldPiece);
  effects.template doBlockAt<NumBitmapEffect::Add,false>(*this,to,num);
  effects.template doEffect<NumBitmapEffect::Sub,false>(*this,ptypeO,to,num);
  setBoard(to,Piece::EMPTY());
  pieces_onboard[P].xorMask(numIndex,numMask);
  stand_count[P][ptype-PTYPE_BASIC_MIN]++;
  standMask(P).xorMask(numIndex,numMask);
{
             const MobilityTable& mobility_backup)
             const CArray<uint64_t,2>& king8infos_backup,
             const CArray<PieceMask,2>& effected_changed_mask_backup,
             const CArray<PieceMask,2>& effected_mask_backup,
             const KingMobility& king_mobility_backup,
             const CArray<PieceMask,2>& pin_or_open_backup,
             int num, PtypeO ptypeO, int numIndex, mask_t numMask,
epilogueDrop(Player2Type<P>, Square to, Ptype ptype, Piece oldPiece, 
void osl::NumEffectState::
template<osl::Player P>
    promoted.set(num0);
  if (promoteMask)
  effects.effected_mask[WHITE].reset(num1);
  effects.effected_mask[BLACK].reset(num1);
  promoted.reset(num1);
  promoted_backup = promoted;
  }
    recalcPinOpen(to,lastD,alt(P));
    recalcPinOpen(from,lastD,alt(P));
    pin_or_open[alt(P)].reset(num1); // captured is not pin
    pin_or_open[alt(P)].reset(num0);
    Direction lastD=UL;
  {
  }
    recalcPinOpen(to,lastD,P);
    recalcPinOpen(from,lastD,P);
    pin_or_open[P].reset(num1); // captured is not pin
    pin_or_open[P].reset(num0);
    Direction lastD=UL;
  else {
    makePinOpen(P);
  if (oldPtypeO == newPtypeO(P,KING))

  effects.template doEffect<NumBitmapEffect::Add,true>(*this,new_ptypeo,to,num0);
  setBoard(to,newPiece);
  effects.effectedNumTable[num1].clear();
  effects.effectedNumTable[num0]=effects.effectedNumTable[num1];
  effects.template doBlockAt<NumBitmapEffect::Add,true>(*this,from,num0);
  setBoard(from,Piece::EMPTY());
  effects.template doEffect<NumBitmapEffect::Sub,true>(*this,oldPtypeO,from,num0);
  effects.template doEffect<NumBitmapEffect::Sub,true>(*this,capturePtypeO,to,num1);
  effects.setChangedPieces(effectSetAt(to));
  effects.clearEffectedChanged();
  effects.clearChangedEffects();
  stand_count[P][unpromote(getPtype(capturePtypeO))-PTYPE_BASIC_MIN]++;
  capturePtypeO=target.ptypeO();
  new_ptypeo=newPiece.ptypeO();
  oldPtypeO=oldPiece.ptypeO();
      
  setPieceOf(num1,target.captured());
  setPieceOf(num0,newPiece);
  num0=oldPiece.number();
  newPiece+=(to-from);
  Piece newPiece=oldPiece.promoteWithMask(promoteMask);
  oldPiece=pieceAt(from);
  standMask(P).xorMask(num1Index,num1Mask);
  pieces_onboard[alt(P)].xorMask(num1Index,num1Mask);
  num1Mask=PieceMask::numToMask(num1);
  num1Index=PieceMask::numToIndex(num1);
  num1=target.number();
  effects.template doEffect<NumBitmapEffect::Add,false>(*this,oldPtypeO,from,num0);
  effects.template doEffect<NumBitmapEffect::Add,false>(*this,capturePtypeO,to,num1);
  effects.template doBlockAt<NumBitmapEffect::Sub,false>(*this,from,num0);
  setBoard(to,target);
  setBoard(from,oldPiece);
  effects.template doEffect<NumBitmapEffect::Sub,false>(*this,newPtypeO,to,num0);
  setPieceOf(num1,target);
  setPieceOf(num0,oldPiece);
  effects.effectedNumTable[num0].clear();
  effects.effectedNumTable[num1]=effects.effectedNumTable[num0];
  pieces_onboard[alt(P)].xorMask(num1Index,num1Mask);
  stand_count[P][unpromote(getPtype(capturePtypeO))-PTYPE_BASIC_MIN]--;
  standMask(P).xorMask(num1Index,num1Mask);
{
                const MobilityTable &mobility_backup)
                const CArray<uint64_t,2>& king8infos_backup,
                const CArray<PieceMask,2>& effected_changed_mask_backup,
                const CArray<PieceMask,2>& effected_mask_backup,
                const PieceMask& promoted_backup,
                const KingMobility& king_mobility_backup,
                const CArray<PieceMask,2>& pin_or_open_backup,
                int num1Index, mask_t num1Mask,
                PtypeO newPtypeO, int num0, int num1, 
                Piece oldPiece, PtypeO oldPtypeO, PtypeO capturePtypeO, 
epilogueCapture(Player2Type<P>, Square from, Square to, Piece target, 
void osl::NumEffectState::
template<osl::Player P>

}
  }
      makeKing8Info<WHITE>();
       || pin_or_open[WHITE]!=pin_or_open_backup[WHITE])
    if(changed.anyInRange(Board_Mask_Table3x3.mask(kingSquare<WHITE>()))
      makeKing8Info<BLACK>();
       || pin_or_open[BLACK]!=pin_or_open_backup[BLACK])
    if(changed.anyInRange(Board_Mask_Table3x3.mask(kingSquare<BLACK>()))
    changed.set(to);
    changed.set(from);
    BoardMask changed=changedEffects(BLACK)|changedEffects(WHITE);
  {
  effects.effected_changed_mask[WHITE].set(num0);
  effects.effected_changed_mask[BLACK].set(num0);
    effects.effected_mask[WHITE].reset(num0);
  else
    effects.effected_mask[WHITE].set(num0);
  if(hasEffectAt(WHITE,to))
    effects.effected_mask[BLACK].reset(num0);
  else
    effects.effected_mask[BLACK].set(num0);
  if(hasEffectAt(BLACK,to))
    const Player p = indexToPlayer(z);
  for (int z=0; z<2; ++z) {
  }
    return false;
    }
      std::cerr << effects.effectedNumTable << std::endl;
      }
        }
          }
            std::cerr << "piece=" << pieceOf(num) << ",num=" << num << ",d=" << d << ",v1=" << effects.effectedNumTable[num][d] << ",v2=" << effects1.effectedNumTable[num][d] << std::endl;
          if(effects.effectedNumTable[num][d]!=effects1.effectedNumTable[num][d]){
          Direction d=static_cast<Direction>(i);
        for(int i=0;i<8;i++){
      for(int num=0;num<=39;num++){
        }
          }
            std::cerr << pos << ",real=" << effects.effectSetAt(pos) << ",ideal=" << effects1.effectSetAt(pos) << std::endl;
          {
          if (!(effects1.effectSetAt(pos)==effects.effectSetAt(pos)))
          Square pos(x,y);
        {
        for(int x=9;x>0;x--)
      for(int y=1;y<=9;y++)
      std::cerr << *this;
      std::cerr << "Effect error 1" << std::endl;
    {
    if (showError)
  {
  if (!(effects1==effects))
  effect::NumSimpleEffectTable effects1(*this);
  }
    return false;
      std::cerr << "error before effect\n";
    if (showError)
  {
  if (!SimpleState::isConsistent(showError)) 
{
bool osl::NumEffectState::isConsistent(bool showError) const
#ifndef MINIMAL


}
  king8infos = king8infos_backup;
  effects.mobilityTable = mobility_backup;
  effects.effected_changed_mask = effected_changed_mask_backup;
  effects.effected_mask = effected_mask_backup;
  promoted = promoted_backup;
  king_mobility = king_mobility_backup;
  pin_or_open = pin_or_open_backup;
  effects.invalidateChangedEffects();
          each_effect[i].set(sq);
        if (effectSetAt(sq).test(i))
      for (int i=0; i<Piece::SIZE; ++i) {
      const Square sq(x, y);
    for (int y=1; y<=9; ++y) {
  for (int x=1; x<=9; ++x) {
  }
    prev_effect[i].clear();
    each_effect[i].clear();
  for (int i=0; i<Piece::SIZE; ++i) {
  CArray<BoardMask, Piece::SIZE> each_effect, prev_effect;
  const BoardMask changed_all = changed_squares[BLACK] | changed_squares[WHITE];
    = {{ changedEffects(BLACK), changedEffects(WHITE) }};
  const CArray<BoardMask,2> changed_squares
  // test changedEffects
{
bool osl::NumEffectState::isConsistent(const NumEffectState& prev, Move moved, bool show_error) const

#endif
}
  return true;
  }
    }
      }
        return false;
          std::cerr << "promoted differs " << p << " " << promoted << " " << promoted.test(i) << "\n";
        if (showError)
      if (promoted.test(i) != p.isPromoted()) {
    if (p.isOnBoard()) {
    const Piece p = pieceOf(i);
  for (int i=0; i<Piece::SIZE; ++i) {
  }
    }      
      return false;
        std::cerr << "king8info for " << p << " differs \n" << King8Info(Iking8Info(p)) << "\n" << king8info2 << "\n";
      if (showError)
    if (King8Info(Iking8Info(p)).uint64Value() != king8info2.uint64Value()) {
    King8Info king8info2 = King8Info::make(alt(p), *this);
#endif
    }
      return false;
        std::cerr << "pin for " << p << " differs " << pin(p) << " " << pin2 << "\n";
      if (showError)
    if (pin(p) != pin2) {
    const PieceMask pin2 = effect_util::Pin::make(*this, p);
#if 0
#endif
      continue;
    if (kingSquare(p).isPieceStand())
#ifdef ALLOW_KING_ABSENCE
      const Player pl = indexToPlayer(j);
    {
    for (int j=0; j<2; ++j) 
  {
  for (int i=0; i<Piece::SIZE; ++i) 
  // test effectedChanged(Player pl)
  }
    }
      return false;
#endif
                  << " " << each_effect[i] << " != " <<  prev_effect[i] << "\n";
        std::cerr << "changedPieces() unset\n" << *this << moved << i 
      if (show_error)
#ifndef MINIMAL
    if (! changed_effect_pieces.test(i)) {
      continue;
    if (each_effect[i] == prev_effect[i])
  for (int i=0; i<Piece::SIZE; ++i) {
  const NumBitmapEffect changed_effect_pieces = changedPieces(); 
  // test changedPieces()
  }
    }
      }
        }
          }
            return false;
#endif
              std::cerr << "changedEffects unset for " << pl << "\n" << *this << moved << sq << "\n";
            if (show_error)
#ifndef MINIMAL
              != (prev.effectSetAt(sq) & prev.piecesOnBoard(pl))) {
          if ((effectSetAt(sq) & piecesOnBoard(pl))
        {
        if (! changed_squares[pl].test(sq))
        const Player pl = indexToPlayer(i);
      {
      for (int i=0; i<2; ++i) 
      }
        }
          return false;
#endif
            std::cerr << "changedEffects unset\n" << *this << moved << sq << "\n";          
          if (show_error)
#ifndef MINIMAL
        if (effectSetAt(sq) != prev.effectSetAt(sq)) {
      {
      if (! changed_all.test(sq))
      }
          prev_effect[i].set(sq);
        if (prev.effectSetAt(sq).test(i))
#endif
  show_error=false;
#ifdef MINIMAL
isAlmostValidMove(Move move,bool show_error) const{
bool osl::NumEffectState::

}
  return true;
  }
    return false;
    }
      std::cerr << " No such move2 : " << move << std::endl;
    if (show_error) {
  if(!hasEffectByPiece(from_piece,to)){
    return false;
  if (! testValidityOtherThanEffect<show_error>(move))
    
  const Piece from_piece = this->pieceAt(from);
  const Square to=move.to();
    return isAlmostValidDrop<show_error>(move);
  if (from.isPieceStand()) // 打つ手
  const Square from=move.from();

  assert(isValidMoveByRule(move, true));
  assert(this->turn() == move.player());
  assert(move.isNormal());
  assert(move.isValid());
osl::NumEffectState::isAlmostValidMove(Move move) const{
#endif
__attribute__ ((used,noinline))
#if (defined __GNUC__) && (! defined GPSONE) && (! defined GPSUSIONE)
bool
template <bool show_error>

}
  return true;
  }
    }
      }
        }
          return false;
#endif
                      << " " << prev.effectedChanged(pl) << " != " << prev.effectedChanged(WHITE) << "\n";
            std::cerr << "effectedChanged(" << pl << ") unset\n" << *this << moved << i 
          if (show_error)
#ifndef MINIMAL
        if (! effectedChanged(pl).test(i)) {
      if (prev.effectedMask(pl).test(i) != effectedMask(pl).test(i)) {
        continue;                // captured
      if (prev.pieceOf(i).square() == moved.to())
void osl::NumEffectState::

}
  return pins;
  makePinOpenDir<DR>(target,pins,mask,defense);
  makePinOpenDir<D>(target,pins,mask,defense);
  makePinOpenDir<DL>(target,pins,mask,defense);
  makePinOpenDir<R>(target,pins,mask,defense);
  makePinOpenDir<L>(target,pins,mask,defense);
  makePinOpenDir<UR>(target,pins,mask,defense);
  makePinOpenDir<U>(target,pins,mask,defense);
  makePinOpenDir<UL>(target,pins,mask,defense);
  PieceMask mask=piecesOnBoard(alt(defense));
  if(target.isPieceStand()) return pins;
  PieceMask pins;
{
makePinOpen(osl::Square target,osl::Player defense)
osl::PieceMask osl::NumEffectState::

#endif
}
  }
    }
         << std::endl;
      os << "P-00" << csa::show(Piece_Table.getPtypeOf(num))
    else if (standMask(WHITE).test(num)){
    }
         << std::endl;
      os << "P+00" << csa::show(Piece_Table.getPtypeOf(num))
    if (standMask(BLACK).test(num)){
  for(int num=0;num<Piece::SIZE;num++){
  // 持ち駒の表示
  }
    os << std::endl;
    }
      os << csa::show(pieceAt(pos)) << effectSetAt(pos);
      Square pos(x,y);
    for(int x=9;x>0;x--){
    os << 'P' << y;  
  for(int y=1;y<=9;y++){
  os<< static_cast<SimpleState const&>(*this);
{
void osl::NumEffectState::showEffect(std::ostream& os) const
#ifndef MINIMAL

}
    return isAlmostValidMove<false>(move);
  else
    return isAlmostValidMove<true>(move);
  if(show_error)
    *((v2di*)&(*this).board[16])=b16;

    v2di b56=*((v2di*)&src.board[56]);
    v2di b52=*((v2di*)&src.board[52]);
    v2di b48=*((v2di*)&src.board[48]);
    v2di b40=*((v2di*)&src.board[40]);
    v2di b36=*((v2di*)&src.board[36]);
    v2di b32=*((v2di*)&src.board[32]);
    v2di b24=*((v2di*)&src.board[24]);
    v2di b20=*((v2di*)&src.board[20]);
    v2di b16=*((v2di*)&src.board[16]);
  {  
#if (defined(__i386__) || defined(__x86_64__)) && !defined(OSL_NO_SSE)
  (*this).stand_mask=src.stand_mask;
#endif
  (*this).used_mask=src.used_mask;
#ifndef MINIMAL
{
void osl::NumEffectState::copyFrom(const NumEffectState& src)

}
  return mask_t();
  }
    assert(0);
  default:
    return allEffectAt<KING>(attack, target);
  case KING:
    return allEffectAt<ROOK>(attack, target);
  case ROOK: case PROOK:
    return allEffectAt<BISHOP>(attack, target);
  case BISHOP: case PBISHOP:
    return allEffectAt<GOLD>(attack, target);
  case GOLD:
    return allEffectAt<SILVER>(attack, target);
  case SILVER: case PSILVER:
    return allEffectAt<KNIGHT>(attack, target);
  case KNIGHT: case PKNIGHT:
    return allEffectAt<LANCE>(attack, target);
  case LANCE: case PLANCE:
    return allEffectAt<PAWN>(attack, target);
  case PAWN: case PPAWN:
  switch (ptype) {
{
allEffectAt(Player attack, Ptype ptype, Square target) const
const osl::mask_t osl::NumEffectState::

}
  pin_or_open[defense]=makePinOpen(kingSquare(defense),defense);
{
makePinOpen(osl::Player defense)
    *((v2di*)&(*this).board[120])=b120;
    *((v2di*)&(*this).board[116])=b116;
    *((v2di*)&(*this).board[112])=b112;

    v2di b152=*((v2di*)&src.board[152]);
    v2di b148=*((v2di*)&src.board[148]);
    v2di b144=*((v2di*)&src.board[144]);

    v2di b136=*((v2di*)&src.board[136]);
    v2di b132=*((v2di*)&src.board[132]);
    v2di b128=*((v2di*)&src.board[128]);

    v2di b120=*((v2di*)&src.board[120]);
    v2di b116=*((v2di*)&src.board[116]);
    v2di b112=*((v2di*)&src.board[112]);

    *((v2di*)&(*this).board[104])=b104;
    *((v2di*)&(*this).board[100])=b100;
    *((v2di*)&(*this).board[96])=b96;

    *((v2di*)&(*this).board[88])=b88;
    *((v2di*)&(*this).board[84])=b84;
    *((v2di*)&(*this).board[80])=b80;

    *((v2di*)&(*this).board[72])=b72;
    *((v2di*)&(*this).board[68])=b68;
    *((v2di*)&(*this).board[64])=b64;


    v2di b104=*((v2di*)&src.board[104]);
    v2di b100=*((v2di*)&src.board[100]);
    v2di b96=*((v2di*)&src.board[96]);

    v2di b88=*((v2di*)&src.board[88]);
    v2di b84=*((v2di*)&src.board[84]);
    v2di b80=*((v2di*)&src.board[80]);

    v2di b72=*((v2di*)&src.board[72]);
    v2di b68=*((v2di*)&src.board[68]);
    v2di b64=*((v2di*)&src.board[64]);


    *((v2di*)&(*this).board[56])=b56;
    *((v2di*)&(*this).board[52])=b52;
    *((v2di*)&(*this).board[48])=b48;
    *((v2di*)&(*this).board[40])=b40;
    *((v2di*)&(*this).board[36])=b36;
    *((v2di*)&(*this).board[32])=b32;
    *((v2di*)&(*this).board[24])=b24;
    *((v2di*)&(*this).board[20])=b20;
  copyFrom(NumEffectState(src));
{
void osl::NumEffectState::copyFrom(const SimpleState& src)

}
  (*this).king8infos=src.king8infos;
  (*this).king_mobility=src.king_mobility;
  (*this).pin_or_open=src.pin_or_open;
  (*this).promoted=src.promoted;
  this->pieces_onboard=src.pieces_onboard;
  effects.copyFrom(src.effects);
  this->player_to_move=src.player_to_move;
  this->stand_count = src.stand_count;
  (*this).pawnMask=src.pawnMask;
#endif
  (*this).pieces=src.pieces;
      (*this).board[Square(x,y).index()]=src.board[Square(x,y).index()];
    for(int y=1;y<=9;y++)
  for(int x=1;x<=9;x++)
#else
  }
    *((v2di*)&(*this).pieces[36])=p36;
    *((v2di*)&(*this).pieces[32])=p32;
    *((v2di*)&(*this).pieces[28])=p28;
    *((v2di*)&(*this).pieces[24])=p24;
    *((v2di*)&(*this).pieces[20])=p20;
    *((v2di*)&(*this).pieces[16])=p16;
    *((v2di*)&(*this).pieces[12])=p12;
    *((v2di*)&(*this).pieces[8])=p8;
    *((v2di*)&(*this).pieces[4])=p4;
    *((v2di*)&(*this).pieces[0])=p0;
    v2di p36=*((v2di*)&src.pieces[36]);
    v2di p32=*((v2di*)&src.pieces[32]);
    v2di p28=*((v2di*)&src.pieces[28]);
    v2di p24=*((v2di*)&src.pieces[24]);
    v2di p20=*((v2di*)&src.pieces[20]);
    v2di p16=*((v2di*)&src.pieces[16]);
    v2di p12=*((v2di*)&src.pieces[12]);
    v2di p8=*((v2di*)&src.pieces[8]);
    v2di p4=*((v2di*)&src.pieces[4]);
    v2di p0=*((v2di*)&src.pieces[0]);

    *((v2di*)&(*this).board[152])=b152;
    *((v2di*)&(*this).board[148])=b148;
    *((v2di*)&(*this).board[144])=b144;

    *((v2di*)&(*this).board[136])=b136;
    *((v2di*)&(*this).board[132])=b132;
    *((v2di*)&(*this).board[128])=b128;

                   return this->isSafeMove(m) && ! this->isPawnDropCheckmate(m);
                 [&](Move m){
    std::copy_if(all_moves.begin(), all_moves.end(), std::back_inserter(moves),
    // 確認が必要
    // この指手は，玉の素抜きがあったり，打歩詰の可能性があるので
    GenerateAllMoves::generate(turn(), *this, all_moves);
    MoveVector all_moves;
    // そうでなければ全ての手を生成
  else {
  }
    GenerateEscapeKing::generate(*this, moves);
    // 王手がかかっている時は防ぐ手のみを生成, 王手回避は不成も生成
  if (inCheck()) {
{
void osl::NumEffectState::generateLegal(MoveVector& moves) const
}
  move_generator::AllMoves<move_action::Store>::generate(turn(), *this, store);
  move_action::Store store(out);
{
void osl::NumEffectState::generateAllUnsafe(MoveVector& out) const
#ifndef MINIMAL

}
  return ConditionAdaptor<OpenCheck>::isMember(*this, move);
  using namespace move_classifier;
{
bool osl::NumEffectState::isOpenCheck(Move move) const

}
  return PlayerMoveAdaptor<DirectCheck>::isMember(*this, move);
  using namespace move_classifier;
{
bool osl::NumEffectState::isDirectCheck(Move move) const
}
  return PlayerMoveAdaptor<PawnDropCheckmate>::isMember(*this, move);
  using namespace move_classifier;
{
bool osl::NumEffectState::isPawnDropCheckmate(Move move) const
}
  return PlayerMoveAdaptor<Check>::isMember(*this, move);
  using namespace move_classifier;
{
bool osl::NumEffectState::isCheck(Move move) const
}
  return ConditionAdaptor<SafeMove>::isMember(*this, move);
  using namespace move_classifier;
{
bool osl::NumEffectState::isSafeMove(Move move) const

}
                  PtypeO&, PtypeO&, PtypeO&, int&, int&, int&, mask_t&,
  prologueCapture(Player2Type<BLACK>, Square, Square, Piece, int, Piece&,
  template void NumEffectState::

                 CArray<uint64_t,2>&, MobilityTable&);
                 PieceMask&, CArray<PieceMask,2>&, CArray<PieceMask,2>&,
                 PtypeO&, PtypeO&, CArray<PieceMask,2>&, KingMobility&,
  prologueSimple(Player2Type<WHITE>, Square, Square, int, Piece&, int&, 
  template void NumEffectState::
                 CArray<uint64_t,2>&, MobilityTable&);
                 PieceMask&, CArray<PieceMask,2>&, CArray<PieceMask,2>&,
                 PtypeO&, PtypeO&, CArray<PieceMask,2>&, KingMobility&,
  prologueSimple(Player2Type<BLACK>, Square, Square, int, Piece&, int&, 
  template void NumEffectState::


  template void NumEffectState::makeKing8Info<WHITE>();
  template void NumEffectState::makeKing8Info<BLACK>();
  hasEffectByWithRemove<WHITE>(Square, Square) const;
  template bool NumEffectState:: 
  hasEffectByWithRemove<BLACK>(Square, Square) const;
  template bool NumEffectState:: 

  // explicit template instantiation
{
namespace osl

}
  forEachEffect(P, target, store);
  effect_action::StorePiece store(&out);
{
findEffect(Player P, Square target, PieceVector& out) const
void osl::NumEffectState::

#endif
}
  }
      moves.push_back(move.unpromote());
    if (move.hasIgnoredUnpromote())
    const Move move = moves[i];
  for (int i=0, iend=moves.size(); i<iend; ++i) {
    return;
  if (inCheck())
  generateLegal(moves);
{
void osl::NumEffectState::generateWithFullUnpromotions(MoveVector& moves) const

}
  }
                 });

}
#endif
  NumEffectState::safeCaptureNotByKing<WHITE>(Square, Piece) const;
  template Piece 
  NumEffectState::safeCaptureNotByKing<BLACK>(Square, Piece) const;
  template Piece 
#ifndef DFPNSTATONE

               const CArray<PieceMask,2>&, const CArray<uint64_t,2>&, const MobilityTable&);  
               const CArray<PieceMask,2>&, const KingMobility&, const CArray<PieceMask,2>&,
  epilogueDrop(Player2Type<WHITE>, Square, Ptype, Piece, int, PtypeO, int, mask_t,
  template void NumEffectState::
               const CArray<PieceMask,2>&, const CArray<uint64_t,2>&, const MobilityTable&);
               const CArray<PieceMask,2>&, const KingMobility&, const CArray<PieceMask,2>&,
  epilogueDrop(Player2Type<BLACK>, Square, Ptype, Piece, int, PtypeO, int, mask_t,
  template void NumEffectState::
                  const MobilityTable&);
                  const CArray<PieceMask,2>&, const CArray<uint64_t,2>&,
                  const KingMobility&, const PieceMask&, const CArray<PieceMask,2>&,
                  PtypeO, int, int, int, mask_t, const CArray<PieceMask,2>&,
  epilogueCapture(Player2Type<WHITE>, Square, Square, Piece, Piece, PtypeO, PtypeO, 
  template void NumEffectState::
                  const MobilityTable&);
                  const CArray<PieceMask,2>&, const CArray<uint64_t,2>&,
                  const KingMobility&, const PieceMask&, const CArray<PieceMask,2>&,
                  PtypeO, int, int, int, mask_t, const CArray<PieceMask,2>&,
  epilogueCapture(Player2Type<BLACK>, Square, Square, Piece, Piece, PtypeO, PtypeO, 
  template void NumEffectState::

               CArray<uint64_t,2>&, MobilityTable&);
               CArray<PieceMask,2>&, CArray<PieceMask,2>&,
               int&, mask_t&, CArray<PieceMask,2>&, KingMobility&,
  prologueDrop(Player2Type<WHITE>, Square, Ptype, Piece&, int&, PtypeO&, 
  template void NumEffectState::
               CArray<uint64_t,2>&, MobilityTable&);
               CArray<PieceMask,2>&, CArray<PieceMask,2>&,
               int&, mask_t&, CArray<PieceMask,2>&, KingMobility&,
  prologueDrop(Player2Type<BLACK>, Square, Ptype, Piece&, int&, PtypeO&, 
  template void NumEffectState::

                  CArray<uint64_t,2>&, MobilityTable&);
                  CArray<PieceMask,2>&, CArray<PieceMask,2>&,
                  CArray<PieceMask,2>&, KingMobility&, PieceMask&,
                  PtypeO&, PtypeO&, PtypeO&, int&, int&, int&, mask_t&,
  prologueCapture(Player2Type<WHITE>, Square, Square, Piece, int, Piece&,
  template void NumEffectState::
                  CArray<uint64_t,2>&, MobilityTable&);
                  CArray<PieceMask,2>&, CArray<PieceMask,2>&,
                  CArray<PieceMask,2>&, KingMobility&, PieceMask&,
// ;;; End:
// ;;; c-basic-offset:2
// ;;; mode:c++
// ;;; Local Variables:
/* ------------------------------------------------------------------------- */
